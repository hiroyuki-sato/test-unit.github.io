<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Module: Test::Unit
  
    &mdash; test-unit
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" media="screen" charset="utf-8" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '../';
  framesUrl = "../frames.html#!" + escape(window.location.href);
</script>


  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="../_index.html">Index (U)</a> &raquo;
    <span class="title"><span class="object_link"><a href="../Test.html" title="Test (module)">Test</a></span></span>
     &raquo; 
    <span class="title">Unit</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link" href="../class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link" href="../method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link" href="../file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><h1>Module: Test::Unit
  
  
  
</h1>

<dl class="box">
  
  
    
  
    
  
  
  
    <dt class="r1 last">Defined in:</dt>
    <dd class="r1 last">lib/test/unit.rb<span class="defines">,<br />
  lib/test-unit.rb,<br /> lib/test/unit/data.rb,<br /> lib/test/unit/diff.rb,<br /> lib/test/unit/color.rb,<br /> lib/test/unit/error.rb,<br /> lib/test/unit/version.rb,<br /> lib/test/unit/pending.rb,<br /> lib/test/unit/fixture.rb,<br /> lib/test/unit/failure.rb,<br /> lib/test/unit/priority.rb,<br /> lib/test/unit/testcase.rb,<br /> lib/test/unit/omission.rb,<br /> lib/test/unit/collector.rb,<br /> lib/test/unit/testsuite.rb,<br /> lib/test/unit/attribute.rb,<br /> lib/test/unit/assertions.rb,<br /> lib/test/unit/autorunner.rb,<br /> lib/test/unit/runner/xml.rb,<br /> lib/test/unit/testresult.rb,<br /> lib/test/unit/util/output.rb,<br /> lib/test/unit/color-scheme.rb,<br /> lib/test/unit/runner/emacs.rb,<br /> lib/test/unit/notification.rb,<br /> lib/test/unit/collector/dir.rb,<br /> lib/test/unit/collector/xml.rb,<br /> lib/test/unit/ui/testrunner.rb,<br /> lib/test/unit/collector/load.rb,<br /> lib/test/unit/runner/console.rb,<br /> lib/test/unit/util/observable.rb,<br /> lib/test/unit/exceptionhandler.rb,<br /> lib/test/unit/util/procwrapper.rb,<br /> lib/test/unit/testsuitecreator.rb,<br /> lib/test/unit/attribute-matcher.rb,<br /> lib/test/unit/ui/xml/testrunner.rb,<br /> lib/test/unit/ui/emacs/testrunner.rb,<br /> lib/test/unit/code-snippet-fetcher.rb,<br /> lib/test/unit/assertionfailederror.rb,<br /> lib/test/unit/collector/descendant.rb,<br /> lib/test/unit/util/backtracefilter.rb,<br /> lib/test/unit/collector/objectspace.rb,<br /> lib/test/unit/ui/testrunnermediator.rb,<br /> lib/test/unit/ui/console/testrunner.rb,<br /> lib/test/unit/ui/testrunnerutilities.rb,<br /> lib/test/unit/ui/console/outputlevel.rb,<br /> lib/test/unit/fault-location-detector.rb,<br /> lib/test/unit/util/method-owner-finder.rb</span>
</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    
<h1>Test::Unit - Ruby Unit Testing Framework</h1>

<h2>Introduction</h2>

<p>Unit testing is making waves all over the place, largely due to the fact
that it is a core practice of XP. While XP is great, unit testing has been
around for a long time and has always been a good idea. One of the keys to
good unit testing, though, is not just writing tests, but having tests.
What's the difference? Well, if you just <em>write</em> a test and throw it
away, you have no guarantee that something won't change later which breaks
your code. If, on the other hand, you <em>have</em> tests (obviously you
have to write them first), and run them as often as possible, you slowly
build up a wall of things that cannot break without you immediately knowing
about it. This is when unit testing hits its peak usefulness.</p>

<p>Enter Test::Unit, a framework for unit testing in Ruby, helping you to
design, debug and evaluate your code by making it easy to write and have
tests for it.</p>

<h2>Notes</h2>

<p>Test::Unit has grown out of and superceded Lapidary.</p>

<h2>Feedback</h2>

<p>I like (and do my best to practice) XP, so I value early releases, user
feedback, and clean, simple, expressive code. There is always room for
improvement in everything I do, and Test::Unit is no exception. Please, let
me know what you think of Test::Unit as it stands, and what you'd like to
see expanded/changed/improved/etc. If you find a bug, let me know ASAP; one
good way to let me know what the bug is is to submit a new test that
catches it :-) Also, I'd love to hear about any successes you have with
Test::Unit, and any documentation you might add will be greatly
appreciated. My contact info is below.</p>

<h2>Contact Information</h2>

<p>A lot of discussion happens about Ruby in general on the ruby-talk mailing
list (<a href="http://www.ruby-lang.org/en/ml.html">www.ruby-lang.org/en/ml.html</a>),
and you can ask any questions you might have there. I monitor the list, as
do many other helpful Rubyists, and you're sure to get a quick answer. Of
course, you're also welcome to email me (Nathaniel Talbott) directly at <a href="mailto:testunit@talbott.ws">testunit@talbott.ws</a>, and I'll do my
best to help you out.</p>

<h2>Credits</h2>

<p>I'd like to thank...</p>

<p>Matz, for a great language!</p>

<p>Masaki Suketa, for his work on RubyUnit, which filled a vital need in the
Ruby world for a very long time. I'm also grateful for his help in
polishing Test::Unit and getting the RubyUnit compatibility layer right.
His graciousness in allowing Test::Unit to supercede RubyUnit continues to
be a challenge to me to be more willing to defer my own rights.</p>

<p>Ken McKinlay, for his interest and work on unit testing, and for his
willingness to dialog about it. He was also a great help in pointing out
some of the holes in the RubyUnit compatibility layer.</p>

<p>Dave Thomas, for the original idea that led to the extremely simple
"require 'test/unit'", plus his code to improve it even more by allowing
the selection of tests from the command-line. Also, without RDoc, the
documentation for Test::Unit would stink a lot more than it does now.</p>

<p>Everyone who's helped out with bug reports, feature ideas, encouragement to
continue, etc. It's a real privilege to be a part of the Ruby community.</p>

<p>The guys at RoleModel Software, for putting up with me repeating, "But this
would be so much easier in Ruby!" whenever we're coding in Java.</p>

<p>My Creator, for giving me life, and giving it more abundantly.</p>

<h2>License</h2>

<p>Test::Unit is copyright (c) 2000-2003 Nathaniel Talbott. It is free
software, and is distributed under the Ruby license. See the COPYING file.</p>

<p>Exception: lib/test/unit/diff.rb is copyright (c) 2008-2010 Kouhei Sutou
and 2001-2008 Python Software Foundation. It is free software, and is
distributed under the Ruby license and/or the PSF license. See the COPYING
file and PSFL file.</p>

<h2>Warranty</h2>

<p>This software is provided "as is" and without any express or implied
warranties, including, without limitation, the implied warranties of
merchantibility and fitness for a particular purpose.</p>

<h2>Author</h2>

<p>Nathaniel Talbott. Copyright (c) 2000-2003, Nathaniel Talbott</p>
<hr style="height: 2px">

<h1>Usage</h1>

<p>The general idea behind unit testing is that you write a <em>test</em>
<em>method</em> that makes certain <em>assertions</em> about your code,
working against a <em>test</em> <em>fixture</em>. A bunch of these
<em>test</em> <em>methods</em> are bundled up into a <em>test</em>
<em>suite</em> and can be run any time the developer wants. The results of
a run are gathered in a <em>test</em> <em>result</em> and displayed to the
user through some UI. So, lets break this down and see how Test::Unit
provides each of these necessary pieces.</p>

<h2>Assertions</h2>

<p>These are the heart of the framework. Think of an assertion as a statement
of expected outcome, i.e. "I assert that x should be equal to y". If, when
the assertion is executed, it turns out to be correct, nothing happens, and
life is good. If, on the other hand, your assertion turns out to be false,
an error is propagated with pertinent information so that you can go back
and make your assertion succeed, and, once again, life is good. For an
explanation of the current assertions, see Test::Unit::Assertions.</p>

<h2>Test Method &amp; Test Fixture</h2>

<p>Obviously, these assertions have to be called within a context that knows
about them and can do something meaningful with their pass/fail value.
Also, it's handy to collect a bunch of related tests, each test represented
by a method, into a common test class that knows how to run them. The tests
will be in a separate class from the code they're testing for a couple of
reasons. First of all, it allows your code to stay uncluttered with test
code, making it easier to maintain. Second, it allows the tests to be
stripped out for deployment, since they're really there for you, the
developer, and your users don't need them. Third, and most importantly, it
allows you to set up a common test fixture for your tests to run against.</p>

<p>What's a test fixture? Well, tests do not live in a vacuum; rather, they're
run against the code they are testing. Often, a collection of tests will
run against a common set of data, also called a fixture. If they're all
bundled into the same test class, they can all share the setting up and
tearing down of that data, eliminating unnecessary duplication and making
it much easier to add related tests.</p>

<p>Test::Unit::TestCase wraps up a collection of test methods together and
allows you to easily set up and tear down the same test fixture for each
test. This is done by overriding #setup and/or #teardown, which will be
called before and after each test method that is run. The TestCase also
knows how to collect the results of your assertions into a
Test::Unit::TestResult, which can then be reported back to you... but I'm
getting ahead of myself. To write a test, follow these steps:</p>
<ul><li>
<p>Make sure Test::Unit is in your library path.</p>
</li><li>
<p>require 'test/unit' in your test script.</p>
</li><li>
<p>Create a class that subclasses Test::Unit::TestCase.</p>
</li><li>
<p>Add a method that begins with "test" to your class.</p>
</li><li>
<p>Make assertions in your test method.</p>
</li><li>
<p>Optionally define #setup and/or #teardown to set up and/or tear down your
common test fixture.</p>
</li><li>
<p>You can now run your test as you would any other Ruby script... try it and
see!</p>
</li></ul>

<p>A really simple test might look like this (#setup and #teardown are
commented out to indicate that they are completely optional):</p>

<pre class="code ruby"><code><span class="id identifier rubyid_require">require</span> <span class="tstring"><span class="tstring_beg">'</span><span class="tstring_content">test/unit</span><span class="tstring_end">'</span></span>

<span class="kw">class</span> <span class="const">MyTest</span> <span class="op">&lt;</span> <span class="const">Test</span><span class="op">::</span><span class="const">Unit</span><span class="op">::</span><span class="const">TestCase</span>
  <span class="comment"># def setup
</span>  <span class="comment"># end
</span>
  <span class="comment"># def teardown
</span>  <span class="comment"># end
</span>
  <span class="kw">def</span> <span class="id identifier rubyid_test_fail">test_fail</span>
    <span class="id identifier rubyid_assert">assert</span><span class="lparen">(</span><span class="kw">false</span><span class="comma">,</span> <span class="tstring"><span class="tstring_beg">'</span><span class="tstring_content">Assertion was false.</span><span class="tstring_end">'</span></span><span class="rparen">)</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre>

<h2>Test Runners</h2>

<p>So, now you have this great test class, but you still need a way to run it
and view any failures that occur during the run. There are some test
runner; console test runner, GTK+ test runner and so on. The console test
runner is automatically invoked for you if you require 'test/unit' and
simply run the file. To use another runner simply set default test runner
ID to Test::Unit::AutoRunner:</p>

<pre class="code ruby"><code><span class="id identifier rubyid_require">require</span> <span class="tstring"><span class="tstring_beg">'</span><span class="tstring_content">test/unit</span><span class="tstring_end">'</span></span>
<span class="const">Test</span><span class="op">::</span><span class="const">Unit</span><span class="op">::</span><span class="const">AutoRunner</span><span class="period">.</span><span class="id identifier rubyid_default_runner">default_runner</span> <span class="op">=</span> <span class="tstring"><span class="tstring_beg">"</span><span class="tstring_content">gtk2</span><span class="tstring_end">"</span></span></code></pre>

<h2>Test Suite</h2>

<p>As more and more unit tests accumulate for a given project, it becomes a
real drag running them one at a time, and it also introduces the potential
to overlook a failing test because you forget to run it. Suddenly it
becomes very handy that the TestRunners can take any object that returns a
Test::Unit::TestSuite in response to a suite method. The TestSuite can, in
turn, contain other TestSuites or individual tests (typically created by a
TestCase). In other words, you can easily wrap up a group of TestCases and
TestSuites.</p>

<p>Test::Unit does a little bit more for you, by wrapping these up
automatically when you require 'test/unit'. What does this mean? It means
you could write the above test case like this instead:</p>

<pre class="code ruby"><code><span class="id identifier rubyid_require">require</span> <span class="tstring"><span class="tstring_beg">'</span><span class="tstring_content">test/unit</span><span class="tstring_end">'</span></span>
<span class="id identifier rubyid_require">require</span> <span class="tstring"><span class="tstring_beg">'</span><span class="tstring_content">test_myfirsttests</span><span class="tstring_end">'</span></span>
<span class="id identifier rubyid_require">require</span> <span class="tstring"><span class="tstring_beg">'</span><span class="tstring_content">test_moretestsbyme</span><span class="tstring_end">'</span></span>
<span class="id identifier rubyid_require">require</span> <span class="tstring"><span class="tstring_beg">'</span><span class="tstring_content">test_anothersetoftests</span><span class="tstring_end">'</span></span></code></pre>

<p>Test::Unit is smart enough to find all the test cases existing in the
ObjectSpace and wrap them up into a suite for you. It then runs the dynamic
suite using the console TestRunner.</p>

<h2>Configuration file</h2>

<p>Test::Unitは現在のワーキングディレクトリにある'test-unit.yml'をTest::Unitの設定ファイルとして読み込みます。このファイルには以下のような設定をすることができます。</p>
<ul><li>
<p>カラースキーム定義</p>
</li><li>
<p>使用するテストランナー</p>
</li><li>
<p>テストランナーのオプション</p>
</li><li>
<p>使用するテスト収集方法</p>
</li></ul>

<p>Except color scheme definitions, all of them are specified by command line
option.</p>

<p>以下はカラースキームの定義例です。</p>

<pre class="code ruby"><code>color_schemes:
  inverted:
    success:
      name: red
      bold: true
    failure:
      name: green
      bold: true
  other_scheme:
    ...</code></pre>

<p>Here are the syntax of color scheme definitions:</p>

<pre class="code ruby"><code>color_schemes:
  SCHEME_NAME:
    EVENT_NAME:
      name: COLOR_NAME
      intensity: BOOLEAN
      bold: BOOLEAN
      italic: BOOLEAN
      underline: BOOLEAN
    ...
  ...</code></pre>
<table class="rdoc-list"><tr><td class="rdoc-term"><p>SCHEME_NAME</p></td>
<td>
<p>カラースキームの名前</p>
</td></tr><tr><td class="rdoc-term"><p>EVENT_NAME</p></td>
<td>
<p>one of [success, failure, pending, omission, notification, error]</p>
</td></tr><tr><td class="rdoc-term"><p>COLOR_NAME</p></td>
<td>
<p>one of [black, red, green, yellow, blue, magenta, cyan, white]</p>
</td></tr><tr><td class="rdoc-term"><p>BOOLEAN</p></td>
<td>
<p>trueまたはfalse</p>
</td></tr></table>

<p>上で定義した'inverted'カラースキムを使う設定は以下の通りです。</p>

<pre class="code ruby"><code>runner: console
console_options:
  color_scheme: inverted
color_schemes:
  inverted:
    success:
      name: red
      bold: true
    failure:
      name: green
      bold: true</code></pre>

<h2>Questions?</h2>

<p>I'd really like to get feedback from all levels of Ruby practitioners about
typos, grammatical errors, unclear statements, missing points, etc., in
this document (or any other).</p>


  


  

Defined Under Namespace

  
    
      Modules: Assertions, Attribute, Collector, Data, Diff, ErrorHandler, ExceptionHandler, FailureHandler, Fixture, NotificationHandler, NullResultContainerInitializer, OmissionHandler, PendingHandler, Priority, TestCaseNotificationSupport, TestCaseOmissionSupport, TestCasePendingSupport, TestResultErrorSupport, TestResultFailureSupport, TestResultNotificationSupport, TestResultOmissionSupport, TestResultPendingSupport, UI, Util
    
  
    
      Classes: AssertionFailedError, AttributeMatcher, AutoRunner, CodeSnippetFetcher, Color, ColorScheme, Error, Failure, FaultLocationDetector, MixColor, Notification, NotifiedError, Omission, OmittedError, PendedError, Pending, TestCase, TestResult, TestSuite, TestSuiteCreator
    
  


  Constant Summary
  
    
      
        VERSION =
          
        
        '2.5.4'
      
        @@at_start_hooks =
          
  
    
  This classvariable is part of a private API.
  You should avoid using this classvariable if possible, as it may be removed or be changed in the future.



  


  


        
        []
      
        @@at_exit_hooks =
          
  
    
  This classvariable is part of a private API.
  You should avoid using this classvariable if possible, as it may be removed or be changed in the future.



  


  


        
        []
      
    
  







  
    
      Class Method Summary
      (collapse)
    

    
      
        
  
    
      + (void) at_exit { ... }
    

    
  
  
  
  
  
  
  
  

  
    
Regsiter a hook that is run after running tests.

  


      
        
  
    
      + (void) at_start { ... }
    

    
  
  
  
  
  
  
  
  

  
    
Regsiter a hook that is run before running tests.

  


      
        
  
    
      + (Object) run=(have_run) 
    

    
  
  
  
  
  
  
  deprecated
  

  
    Deprecated. 
Use Test::Unit::AutoRunner.need_auto_run= instead.

  


      
        
  
    
      + (Boolean) run? 
    

    
  
  
  
  
  
  
  deprecated
  

  
    Deprecated. 
Use Test::Unit::AutoRunner.need_auto_run? instead.

  


      
        
  
    
      + (Object) run_at_exit_hooks 
    

    
  
  
  
  
  
  
  
  private

  
    
  


      
        
  
    
      + (Object) run_at_start_hooks 
    

    
  
  
  
  
  
  
  
  private

  
    
  


      
    
  



  
    Class Method Details

    
      
  
  
    + (void) at_exit { ... }
  

  

  

  
    This method returns an undefined value.
Regsiter a hook that is run after running tests. To register multiple
hooks, call this method multiple times.

Here is an example test case:

Test::Unit.at_exit do
  # ...
end

class TestMyClass1  Test::Unit::TestCase
  class  self
    def shutdown
      # ...
    end
  end

  def teardown
    # ...
  end

  def test_my_class1
    # ...
  end

  def test_my_class2
    # ...
  end
end

class TestMyClass2  Test::Unit::TestCase
  class  self
    def shutdown
      # ...
    end
  end

  def teardown
    # ...
  end

  def test_my_class1
    # ...
  end

  def test_my_class2
    # ...
  end
end

Here is a call order:

TestMyClass1#test_my_class1

TestMyClass1#teardown

TestMyClass1#test_my_class2

TestMyClass1#teardown

TestMyClass1.shutdown

TestMyClass2#test_my_class1

TestMyClass2#teardown

TestMyClass2#test_my_class2

TestMyClass2#teardown

TestMyClass2.shutdown

at_exit



  


  
  
    Examples:
    
      
      Test::Unit.at_exit do
  puts Exit!
end
    
  

Yields:

  
    
      
      
        
      
      
      
        
        
A block that is run after running tests.

      
    
  

Yield Returns:

  
    
      
      
        (void)
      
      
      
    
  

Since:

  
    
      
      
      
      
        
        
2.5.2

      
    
  



  
    
      


485
486
487
    
    
      # File 'lib/test/unit.rb', line 485

def at_exit(hook)
  @@at_exit_hooks  hook
end
    
  


    
      
  
  
    + (void) at_start { ... }
  

  

  

  
    This method returns an undefined value.
Regsiter a hook that is run before running tests. To register multiple
hooks, call this method multiple times.

Here is an example test case:

Test::Unit.at_start do
  # ...
end

class TestMyClass1  Test::Unit::TestCase
  class  self
    def startup
      # ...
    end
  end

  def setup
    # ...
  end

  def test_my_class1
    # ...
  end

  def test_my_class2
    # ...
  end
end

class TestMyClass2  Test::Unit::TestCase
  class  self
    def startup
      # ...
    end
  end

  def setup
    # ...
  end

  def test_my_class1
    # ...
  end

  def test_my_class2
    # ...
  end
end

Here is a call order:

at_start

TestMyClass1.startup

TestMyClass1#setup

TestMyClass1#test_my_class1

TestMyClass1#setup

TestMyClass1#test_my_class2

TestMyClass2#setup

TestMyClass2#test_my_class1

TestMyClass2#setup

TestMyClass2#test_my_class2



  


  
  
    Examples:
    
      
      Test::Unit.at_start do
  puts Start!
end
    
  

Yields:

  
    
      
      
        
      
      
      
        
        
A block that is run before running tests.

      
    
  

Yield Returns:

  
    
      
      
        (void)
      
      
      
    
  

Since:

  
    
      
      
      
      
        
        
2.5.2

      
    
  



  
    
      


400
401
402
    
    
      # File 'lib/test/unit.rb', line 400

def at_start(hook)
  @@at_start_hooks  hook
end
    
  


    
      
  
  
    + (Object) run=(have_run) 
  

  

  

  
    Deprecated. 
Use Test::Unit::AutoRunner.need_auto_run= instead.


Set true when Test::Unit has run.  If set to true Test::Unit will not
automatically run at exit.


  


  


  
    
      


316
317
318
    
    
      # File 'lib/test/unit.rb', line 316

def run=(have_run)
  AutoRunner.need_auto_run = (not have_run)
end
    
  


    
      
  
  
    + (Boolean) run? 
  

  

  

  
    Deprecated. 
Use Test::Unit::AutoRunner.need_auto_run? instead.


Already tests have run?


  


  
Returns:

  
    
      
      
        (Boolean)
      
      
      
    
  



  
    
      


323
324
325
    
    
      # File 'lib/test/unit.rb', line 323

def run?
  not AutoRunner.need_auto_run?
end
    
  


    
      
  
  
    + (Object) run_at_exit_hooks 
  

  

  

  
    
  This method is part of a private API.
  You should avoid using this method if possible, as it may be removed or be changed in the future.



  


  


  
    
      


490
491
492
493
494
    
    
      # File 'lib/test/unit.rb', line 490

def run_at_exit_hooks
  @@at_exit_hooks.each do |hook|
    hook.call
  end
end
    
  


    
      
  
  
    + (Object) run_at_start_hooks 
  

  

  

  
    
  This method is part of a private API.
  You should avoid using this method if possible, as it may be removed or be changed in the future.



  


  


  
    
      


405
406
407
408
409
    
    
      # File 'lib/test/unit.rb', line 405

def run_at_start_hooks
  @@at_start_hooks.each do |hook|
    hook.call
  end
end
    
  


    
  



    

  
</hr></div></div></div></body></html>
